// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© QuantumResearch

//@version=6
indicator('KEMAD | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™ ', overlay = true)

//-----------------------------------------------------------------------------------------
//    ___                    _                   ____                               _      |
//   / _ \ _   _  __ _ _ __ | |_ _   _ _ __ ___ |  _ \ ___  ___  ___  __ _ _ __ ___| |__   |
//  | | | | | | |/ _` | '_ \| __| | | | '_ ` _ \| |_) / _ \/ __|/ _ \/ _` | '__/ __| '_ \  |
//  | |_| | |_| | (_| | | | | |_| |_| | | | | | |  _ <  __/\__ \  __/ (_| | | | (__| | | | |
//   \__\_\\__,_|\__,_|_| |_|\__|\__,_|_| |_| |_|_| \_\___||___/\___|\__,_|_|  \___|_| |_| |
//                                                                                         |
//-----------------------------------------------------------------------------------------                                                                                
ColMode = input.string('Classic', title = 'Color mode', group = 'Visual | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™', options = ['Classic', 'Classic2', 'Classic3', 'Classic4', 'Classic5', 'Classic6', 'Classic7','Classic8'])

[color_up, color_dn] = switch ColMode
    'Classic' => [color.rgb(0, 255, 186), color.rgb(255, 0, 157)]
    'Classic2' => [#10cab8, color.blue]
    'Classic3' => [#5ffae0, #c22ed0]
    'Classic4' => [#ffbb00, #770737]
    'Classic5' => [#9618f7, #ff0078]
    'Classic6' => [#dee2e6, #495057]
    'Classic7' => [#049ef7, color.white]
    'Classic8' => [#13bd6e,#af0d4b]
    // Color Palette
color col_up1 = color_up
color col_up2 = color.new(color_up, 50)
color col_dn1 = color_dn
color col_dn2 = color.new(color_dn, 50)

//--------------------------------------------------------------------------Formula & parameters------------------------------------------------------------------------------

length_atr = input.int(21,title = 'length_atr', group = 'atr & mult Parameters | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™')
len_sma = input.int(25,title = 'length sma', group = 'atr & mult Parameters | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™')

mult_up = input.float(1.5,step = 0.1,title = 'multiplier up', group = 'atr & mult Parameters | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™')
mult_dn = input.float(1.1,step = 0.1,title = 'multiplier down', group = 'atr & mult Parameters | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™')

// Kalman Filter parameters
series float        pricesource          = input.source(close, "Kalman Price Source", group = "Kalman | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™")
simple float        processNoise         = input.float(0.01, title="Process Noise", step = 0.01, group = "Kalman | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™")
simple float        measurementNoise     = input.float(3.0, title="Measurement Noise", group = "Kalman | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™")
simple int          N                    = input.int(5, title="Filter Order", minval=1, group = "Kalman | ğ™Œğ™ªğ™–ğ™£ğ™©ğ™ªğ™¢ğ™ğ™šğ™¨ğ™šğ™–ğ™§ğ™˜ğ™")

//-------------------------------------------------------------------------------KALMAN----------------------------------------------------------------------------------------

var float[] stateEstimate = array.new_float(N, na)
var float[] errorCovariance = array.new_float(N, 100.0)

f_init(series float pricesource) =>
    if na(array.get(stateEstimate, 0))
        for i = 0 to N-1
            array.set(stateEstimate, i, pricesource)
            array.set(errorCovariance, i, 1.0)

f_kalman(series float pricesource) =>
    // Prediction Step
    predictedStateEstimate = array.new_float(N)
    predictedErrorCovariance = array.new_float(N)
    for i = 0 to N-1
        array.set(predictedStateEstimate, i, array.get(stateEstimate, i)) // Simplified prediction
        array.set(predictedErrorCovariance, i, array.get(errorCovariance, i) + processNoise)
    
    kalmanGain = array.new_float(N)
    for i = 0 to N-1
        kg = array.get(predictedErrorCovariance, i) / (array.get(predictedErrorCovariance, i) + measurementNoise)
        array.set(kalmanGain, i, kg)
        array.set(stateEstimate, i, array.get(predictedStateEstimate, i) + kg * (pricesource - array.get(predictedStateEstimate, i)))
        array.set(errorCovariance, i, (1 - kg) * array.get(predictedErrorCovariance, i))
    
    array.get(stateEstimate, 0)

f_init(pricesource)
kalmanFilteredPrice = f_kalman(pricesource)

ema = ta.ema(kalmanFilteredPrice,len_sma)
atr_ = ta.atr(length_atr)
//--------------------------------------------------------------------------Long & Short----------------------------------------------------------------------------------

long = (close > ema + mult_up * atr_) 
short = (close < ema - mult_dn *atr_) 

var Quantum = 0
var color trend_col = na

if long and not short
    Quantum:=1
    trend_col:= col_up1
    trend_col
    Quantum
if short
    Quantum:=-1
    trend_col:=col_dn1
    trend_col
    Quantum

//--------------------------------------------------------------------------Visual & plotting------------------------------------------------------------------------------

barcolor(color=Quantum==1?col_up1:col_dn1)
p1 = plot(ta.ema(close,54), color = trend_col, linewidth = 2, editable = false,style = plot.style_line)
p2 = plot(hl2, display = display.none, editable = false)

// Fill between lines
fill(p1, p2, hl2,ta.ema(close,54), na, color.new(trend_col, 80))